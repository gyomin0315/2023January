/*
#include<stdio.h>
int main(void)
{
	printf("오늘 날짜는 20230110.");
	return 0;
}


C언어 스타일의 기억장소는 a라는 장소에 3이 들어가는 절차지형 언어라면
파이썬은 a라는 장소에 3이라는 위치를 가리키는 주소가 들어가는 객체지향언어.

3은 이진수로 11(2)이고, 4byte로 표현되면 00000000 00000000 00000000 00000011이 될것임.
파이썬은 4byte 앞뒤에 뭔가를 더 붙여서 사이즈가 훨씬 커짐.

# : 파이썬에서는 주석이지만, C언어에서는 전처리기. 컴파일 하기 전에 처리하겠다는 뜻.
<stdio.h> : 표준 입출력 헤더파일. 표준 입력 및 출력과 관련되어 있는 함수들.printf도 여기에 있음.

cf) https://insights.stackoverflow.com/survey/2021#technology : 프로그래밍 언어/ 툴 순위 사이트. 참고만 할 것.


(1) 프로그래밍 언어
- 저급언어와 고급언어의 차이점, 예

저급언어는 기계어, 어셈블리어로 나뉜다. 기계어란 0과 1로 된 CPU 명령어이고, 2진수로 표현되므로 사람이 사용하기에 불편.
어셈블리어란 CPU 명령어에 일대일로 대응되는 니모닉 기호를 사용한다. 어셈블러에 의해 기계어로 변환.
저급 언어는 기계 종속적 언어로, CPU가 어떻게 동작하는지 잘 이해해야 프로그램을 작성할 수 있고, CPU의 종류에 따라 프로그램이 달라진다.

반면, 고급 언어는 C,C++,Java,Python 등으로, 기계 독립적 특성을 가져서, CPU의 종류나 하드웨어의 특성에 얽매이지 않고 프로그램을 작성할 수 있다.

프로그램이란? 컴퓨터 하드웨어가 수행할 일련의 작업을 기술하고 있는 명령어의 모임. 명령어의 모임이 중요 !
명령어는 CPU가 처리할 수 있는 2진 코드이고, 이 때문에 컴파일을 한다.

printf에 대한 정보 어디서 찾을 수 있을까?
program files > micro visual studio > vc > include > stdio.h > 메모장에서 열어봄 
_Check_return_opt_ _CRTIMP int __cdecl printf(_In_z_ _Printf_format_string_ const char* _Format, ...); 이런 정보가 나옴. 즉, stdio.h 안에 printf에 대한 정보 있다.

int : printf 함수에서 반환 하는 수는 정수.
printf() : 라이브러리 함수.
const : 상수화. 중요한 값이니 변화시키지 못하게 하겠다.
const char * : printf 안에 들어가는 수는 어떤 문자열의 첫번째 주솟값이고, 이걸 상수화해서 받아온다.

알고리즘이란 ? 어떤 문제를 논리적으로 해결하기 위한 절차나 방법. 자연어, 순서도, pseudo 코드를 사용해서 기술 가능.
*/
/*
#include <stdio.h>
int main(void)
{
	int a; // a라는 4byte 기억장소를 선언. 이때 4byte 안에는 쓰레기값 있음.
	a = printf("12345 6789"); // 우선 123456789라는 문자열을 출력. printf 자체의 출력 결과물은 9이고, printf가 int형 반환이 있었는데 그 결과물이 여기서의 9임.printf의 입장에서 123456789를 이해할때는 이 123456789라는 문자열의 첫번째 주소가 들어오는거임. print를 끝냈으면 반환값은 문자열의 length를 반환함.


	printf("\n");
	printf("%d", a);
	return 0;
}
*/
//출력결과 
/*
123456789
9
*/
/*
#include <stdio.h>
int main(void)
{
	printf("%d", printf("123456789"));
	return 0;
}
*/
//출력 결과
/*
1234567899
*/

// 123456789의 문자열의 첫번째 주소가 2400번지였으면, printf(2400)으로 이해하고, 2400번지의 문자열부터 NULL까지 출력.
/*
#include <stdio.h>
int main(void)
{
	printf("%d", printf("123456789"));
	printf("\n");
	printf("%d", "123456789");
	return 0;
}
*/
//출력결과
/*
1234567899
469408808 // 123456789라는 문자열에서 가장 첫번째 문자의 주소가 나타남. 
*/
/*

#include <stdio.h>
int main(void)
{
	printf("%d", "123456789");
	printf("\n");
	printf("%u\n", "123456789");
	printf("%p\n", "123456789");
	return 0;

}
*/
//출력결과
/*
1920113704
1920113704
00007FF772729C28
*/

// %는 형식지정자 or 서식지정자. %d는 10진수 표현, %u는 unsigned integer. (양수로만 처리.) , %p는 16진수 표현. 주소 표현할때는 음수나오면 안되니까 %u나 %p 많이 씀.
/*
#include <stdio.h>
int main(void)
{
	printf("%d %u %x %f %s %i %c\n", -123, 45, "abc", 3.14, "abcdef",9000,'A');
	return 0;

}
*/
//출력결과
/*
-123 45 00007FF72D249C18 3.140000 abcdef 9000 A
*/

// %d : 10진수, %u : unsigned integer, %p : pointer. 메모리상의 주소가 대문자 16진수로 나오게 함. %f : floating point 소수를 표현할때 사용하고, 기본 소수점 아래 6자리까지 표현함.
// %s : 문자열 표현 (string), %i : integer 표현(정수), %c : character : 문자 표현

// %d , %x ,%o 각각 10진수, 16진수, 8진수 표현임.
// %x를 사용하게 되면 소문자, %X를 사용하게 되면 대문자가 나옴. %X와 %p의 차이점으로는 %X는 주소를 그대로 16진수로 표현한다면, %p는 포인터의 크기에 맞게 주소를 16진수로 표현한다.
/*
#include <stdio.h>
int main(void)
{
	printf("%5d%5d%-5d\n", 123, 45, 678);
	printf("%.1f%5.3f\n", 123.6789, 45.2345);
	return 0;
}
*/
// 출력 결과
/*
  123   45678
123.745.234
*/
// %5d의 의미는 5칸을 잡고 그 안에 숫자를 출력해라 라는 의미. C는 기본적으로 오른쪽 정렬 ! 그래서 %-5d의 의미는 왼쪽 정렬 하고, 5칸 잡고 출력하라는 의미.
// %.1f는 소수점 첫번째자리 까지 출력하라는 의미. 이때 반올림 한다. 또, 소수점이 칸 수에 포함.
// %5.3f는 5칸 잡고, 소수점 아래 3번째 자리까지 출력해라. 이떄, 앞자리에 한해서 소수점이 2번재 메모리에 들어가게 되면 40의 데이터가 아예 없어지기 때문에 5칸은 넘김.
// 마지막에 반올림이 되지 않은 건 C언어에서 실수의 계산은 정확하지 않기 때문.
// 다음 예제를 보면, 

#include <stdio.h>

int main(void)
{
	float a = 123456.987650;
	printf("a = %f\n", a);
	a = a + 1.53;
	printf("a + 1.53 = %f\n", a);
	return 0;
}
// a의 초기화 값도 제대로 못 들어갔을 뿐더러, 덧셈 결과도 맞지 않는 것 확인 할 수 있다.
// C언어에서 가수부에 숫자를 다 넣지 못해 뒷부분을 잘라내는 현상 발생하기 때문이다. 
// 따라서, 소수의 숫자가 어느정도 많다면, 출력 정밀도, 최대 정밀도, 유효 정밀도를 고려해서 계산해야 한다. 
// 간단한 소수에서도 차이가 나는 이유는, 10진수 실수와 컴퓨터가 이해하는 2진수가 실수형(float나 double)의 경우,
// 10진수와 2진수가 1대1 매칭이 되는것이 아닌, 가수부를 그대로 23bit에 구겨넣기 때문에, 이 가수부 전체를 해석하는 데 있어서 2진수와 10진수의 차이에 해당하는 오차가 생김. 
// 실수 또한 이진수로 표현하기 때문에 가수부가 1/2^n 꼴로 표현되는 경우만 오차없이 정확하게 값이 계산된다.