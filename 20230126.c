// 포인터
/*
#include <stdio.h>

int main(void)
{
	int m, * mp;

	mp = &m;
	*mp = 125;
	printf("m에 들어있는 값 : %d , \"mp\"가 가리키고 있는 값 : %d (*mp로 표현) *는 가리킨다는 의미.\n", m, *mp);
	printf(" \"&mp\" : %u , 포인터 변수 mp에 들어있는 값 : %u\n", &m, mp);


	//printf("%d",sizeof(mp));
	return 0;



}
*/
//출력 결과
/*
m에 들어있는 값 : 125 , "mp"가 가리키고 있는 값 : 125 (*mp로 표현) *는 가리킨다는 의미.
 "&mp" : 1836251108 , 포인터 변수 mp에 들어있는 값 : 1836251108
 */

/*
변수를 선언할때 쓰는 *는, 이 변수가 주소를 저장하는 변수인 포인터 변수라는 걸 알려주기 위해 쓰지만,
값을 넣을때 사용하는 *는 이 변수가 가리키는 값을 의미한다.

또, m은 명확하게 4byte지만, 포인터 변수 mp는 4byte 혹은 8 byte임. *가 있으면 일단 주솟값이 들어간다고 
생각하면 됨. 4byte 혹은 8byte인 이유는 컴퓨터가 32bit냐 64bit냐 차이. 

printf("%d",sizeof(mp));로 확인해봤더니 8byte 나옴. 
*/
/*
#include <stdio.h>

int main(void)
{
	int m[4] = { 2,4,5,8 };
	int i;

	for (i = 0; i < 4; i++) printf("%u\n", &m[i]);
	for (i = 0; i < 4; i++) printf("%d\n", m[i]);
	

	return 0;


}
*/
//출력 결과
/*
123009160
123009164
123009168
123009172
2
4
5
8

*/
/*
i 는 쓰레기값부터 시작해서 0,1,2,3,4,0,1,2,3,4 순으로 바뀜.
배열은 메모리 연속적으로 씀. 그래서 4byte 간격으로 연속적으로 나오는 것 알 수 있음.
주소에다가 *만 붙이면 그 주소의 값이 된다고 생각
*/

/*

#include <stdio.h>

int main(void)
{
	int m[4] = { 2,4,6,9 }, * mp;
	mp = &m[0];
	printf("%u %u %u %u\n", mp , mp + 1, mp + 2, mp + 3);
	printf("%u %u %u %u\n", &m[0], &m[1], &m[2], &m[3]);
	return 0;

}
*/
// 출력 결과
/*
2926572840 2926572844 2926572848 2926572852
2926572840 2926572844 2926572848 2926572852

*/


/*

#include <stdio.h>

int main(void)
{
	int m[4] = { 5,2,6,3 }, i;
	for (i = 0; i <= 3; i++) printf("%u\n", m + i); // 배열명으로 썼던 m은 m = &m[0] 였던 것에 유의. 또, 만약 배열형이 double이였다면 , 주소가 8byte씩 늘어날 것임.

	for (i = 0; i <= 3; i++) printf("%d\n", m[i]);

	for (i = 0; i <= 3; i++) printf("%d\n", *(m + i));

	return 0;

}
*/
//출력 결과
/*
80739032
80739036
80739040
80739044
5
2
6
3
5
2
6
3

*/
/*
#include <stdio.h>

int main(void)
{
	int m[4] = { 2,4,5,3 }, i, * p;

	p = m;

	for (i = 0; i <= 3; i++) printf("%d\n", (p + i));
	return 0;

}
*/
//출력 결과
/*
2104490008
2104490012
2104490016
2104490020
*/
/*
#include <stdio.h>

int main(void)
{
	float k[3][2] = { {170.5, 168.3}, {172.4,158.2},{180.2,150.3} };
	int i;

	for (i = 0; i <= 1; i++) printf("k[0][%d] = %6.1f\n", i, k[0][i]);
	for (i = 0; i <= 1; i++) printf("k[1][%d] = %6.1f\n", i, k[1][i]);
	for (i = 0; i <= 1; i++) printf("k[2][%d] = %6.1f\n", i, k[2][i]);


	return 0;

}
*/
//출력 결과
/*
k[0][0] =  170.5
k[0][1] =  168.3
k[1][0] =  172.4
k[1][1] =  158.2
k[2][0] =  180.2
k[2][1] =  150.3

*/

#include <stdio.h>

int main(void)
{
	int k[2][3] = { {2,4,6},{8,10,12} };

	int i;

	printf("%d %u %d\n", k[0][2], *(k[0]+2), *(k[1] - 1));
	printf("%d %d %d\n", *(k[1] + 1), k[1][1], *(k[0] + 4));

	for (i = 0; i <= 2; i++) printf("k[0][%d] = %d\n", i, k[0][i]);
	for (i = 0; i <= 2; i++) printf("k[1][%d] = %d\n", i, k[1][i]);

	//printf("%u %u", k, k[0]);

	//printf("%u %u", k, k + 1);
	

	return 0;



}

//출력 결과
/*
6 6 6
10 10 10
k[0][0] = 2
k[0][1] = 4
k[0][2] = 6
k[1][0] = 8
k[1][1] = 10
k[1][2] = 12

*/


// 중요 //

// 2차원 배열부터 함정에 빠지지 말아야 할 점이, 2차원 배열의 배열명은 하나의 행 전체를 대표하는 값이됨.
// 즉, k는 2차원 배열의 첫번째 행 전체를 대표하고, k+1은 2차원 배열의 두번째 행 전체를 대표함.
// 그래서, 어느 값을 출력하고 싶을때, 2차원 배열에서는 1차원 처럼 *(k+1) 이런식으로 구하면 안되고,
// *(k[0]+1)처럼 구해야함.
// 또, k[0], k[1], k[2].. 이런 애들이 각 행의 첫번 주솟값들임. k=k[0], k+1 = k[1] , ...


